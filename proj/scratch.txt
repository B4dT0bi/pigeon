


              H   G   F   E   D   C   B   A
             ___ ___ ___ ___ ___ ___ ___ ___
         1|    .   .   .   .   .   .   .   .
         2|  -28  -4 -10 -32 -38 -42 -23 -27     
 PAWN    3|  -23  -5 -18 -29 -36 -39 -21 -30           
         4|  -25  -8 -16 -17 -18 -30 -17 -20       
(delta   5|  -11   0 -13  -8 -17 -30  -6  -4             
 from    6|   16  33  23  22  29  33  38  32	           
 100)    7|   35  56  47  59  65  84  92  76	          
         8|    .   .   .   .   .   .   .   .       
                                     		         
         1|  -74 -16 -40 -36 -40 -52 -31 -79       
         2|  -31 -31 -15 -15 -15 -23 -34 -60       
KNIGHT   3|  -25  -4  -2  11   7  -6 -18 -31             
         4|   -3  23  21  19   9  15   5 -18       
(delta   5|   29  26  48  29  43  30  13   6                        
 from    6|   32  39  58  50  48  32  26   2	           
 250)    7|   15  13  40  49  33  31   3  -7	          
         8|  -83  13  13  27  12   2   0-105       
                                     		         
         1|  -33 -21 -16 -26 -22 -19 -14 -22       
         2|  -16   0  -4  -7 -15   0 -10  -7       
BISHOP   3|   -5  -2  -1   6   2   4   7  -5             
         4|   -5   5   0  16  20  10   8   3       
(delta   5|    9  -6  23  23  27  18   0  -2             
 from    6|   23  27  29  27  28  18  20   6	           
 275)    7|    4   4  18  12  11  14  13   2	          
         8|  -11   2  -5   5   3   1   0  -5                  
                                     		         
         1|  -43 -22 -32 -25 -21 -24 -30 -42       
         2|  -37 -26 -30 -30 -29 -28 -33 -41       
 ROOK    3|  -21  -8 -20 -23 -24 -21 -17 -26           
         4|   -8   3   0  -4  -2  -2  -1  -8       
(delta   5|   13  18  21  16  17  16  15  14             
 from    6|   25  32  34  31  30  30  28  23	                      
 435)    7|   28  33  35  34  36  35  29  27	          
         8|   29  23  24  26  28  25  24  21       
                                     		                    
         1|  -55 -83 -80 -51 -41 -62 -65 -44                             
         2|  -52 -60 -51 -38 -38 -46 -45 -45       
 QUEEN   3|  -16 -14 -26 -30 -38 -32 -45 -38            
         4|    1   3  -5 -10 -21 -22 -24 -41       
(delta   5|   30  42  29  22  15   1 -17 -29             
 from    6|   58  96  76  50  28  12   6 -19	                      
 850)    7|   86  60  61  43  32  24  -1 -13	          
         8|   73  55  52  46  33  22  14   3       
             
         1|  -22 -10 -38 -24 -39 -12   4  -1                
         2|  -20 -15 -21 -22 -20 -20 -13  -4     
 KING    3|  -26 -14 -12 -10 -12 -11  -9 -19           
         4|  -19  -2  -0  -2  -2  -0   1 -13     
         5|  -10   2   2  -2  -3   7   8  -5     
         6|   -6  27  13   2   6  14  23   1     
         7|   14  38  24  16  16  21  28   3     
         8|   -3  34  23  15  12   8  19  -5     







            H   G   F   E   D   C   B   A        H   G   F   E   D   C   B   A
                 --- --- --- --- --- --- --- ------ --- --- --- --- --- --- ---
       1|    .   .   .   .   .   .   .   .        .   .   .   .   .   .   .   .
  PAWN 2|   72  96  90  68  62  58  77  73      -28  -4 -10 -32 -38 -42 -23 -27
       3|   77  95  82  71  64  61  79  70      -23  -5 -18 -29 -36 -39 -21 -30 
       4|   75  92  84  83  82  70  83  80      -25  -8 -16 -17 -18 -30 -17 -20 
       5|   89 100  87  92  83  70  94  96      -11   0 -13  -8 -17 -30  -6  -4 (delta
       6|  116 133 123 122 129 133 138 132       16  33  23  22  29  33  38  32	 from 
       7|  135 156 147 159 165 184 192 176       35  56  47  59  65  84  92  76	 100)
       8|    .   .   .   .   .   .   .   .        .   .   .   .   .   .   .   .
                                                                        
       1|  176 234 210 214 210 198 219 171      -74 -16 -40 -36 -40 -52 -31 -79
KNIGHT 2|  219 219 235 235 235 227 216 190      -31 -31 -15 -15 -15 -23 -34 -60
       3|  225 246 248 261 257 244 232 219      -25  -4  -2  11   7  -6 -18 -31 
       4|  247 273 271 269 259 265 255 232       -3  23  21  19   9  15   5 -18 
       5|  279 276 298 279 293 280 263 256       29  26  48  29  43  30  13   6 (delta
       6|  282 289 308 300 298 282 276 252       32  39  58  50  48  32  26   2	 from 
       7|  265 263 290 299 283 281 253 243       15  13  40  49  33  31   3  -7	 250)
       8|  167 263 263 277 262 252 250 145      -83  13  13  27  12   2   0-105
                                                                        
       1|  242 254 259 249 253 256 261 253      -33 -21 -16 -26 -22 -19 -14 -22
BISHOP 2|  259 275 271 268 260 275 265 268      -16   0  -4  -7 -15   0 -10  -7
       3|  270 273 274 281 277 279 282 270       -5  -2  -1   6   2   4   7  -5 
       4|  270 280 275 291 295 285 283 278       -5   5   0  16  20  10   8   3 
       5|  284 269 298 298 302 293 275 273        9  -6  23  23  27  18   0  -2 (delta
       6|  298 302 304 302 303 293 295 281       23  27  29  27  28  18  20   6	 from 
       7|  279 279 293 287 286 289 288 277        4   4  18  12  11  14  13   2	 275)
       8|  264 277 270 280 278 276 275 270      -11   2  -5   5   3   1   0  -5
                                                                        
       1|  392 413 403 410 414 411 405 393      -43 -22 -32 -25 -21 -24 -30 -42
  ROOK 2|  398 409 405 405 406 407 402 394      -37 -26 -30 -30 -29 -28 -33 -41
       3|  414 427 415 412 411 414 418 409      -21  -8 -20 -23 -24 -21 -17 -26 
       4|  427 438 435 431 433 433 434 427       -8   3   0  -4  -2  -2  -1  -8 
       5|  448 453 456 451 452 451 450 449       13  18  21  16  17  16  15  14 (delta
       6|  460 467 469 466 465 465 463 458       25  32  34  31  30  30  28  23	 from 
       7|  463 468 470 469 471 470 464 462       28  33  35  34  36  35  29  27	 435)
       8|  464 458 459 461 463 460 459 456       29  23  24  26  28  25  24  21
                                                                        
       1|  795 767 770 799 809 788 785 806      -55 -83 -80 -51 -41 -62 -65 -44
 QUEEN 2|  798 790 799 812 812 804 805 805      -52 -60 -51 -38 -38 -46 -45 -45 
       3|  834 836 824 820 812 818 805 812      -16 -14 -26 -30 -38 -32 -45 -38 
       4|  851 853 845 840 829 828 826 809        1   3  -5 -10 -21 -22 -24 -41 
       5|  880 892 879 872 865 851 833 821       30  42  29  22  15   1 -17 -29	(delta
       6|  908 946 926 900 878 862 856 831       58  96  76  50  28  12   6 -19	 from 
       7|  936 910 911 893 882 874 849 837       86  60  61  43  32  24  -1 -13	 850)
       8|  923 905 902 896 883 872 864 853       73  55  52  46  33  22  14   3
      
       1|  -22 -10 -38 -24 -39 -12   4  -1
  KING 2|  -20 -15 -21 -22 -20 -20 -13  -4
       3|  -26 -14 -12 -10 -12 -11  -9 -19
       4|  -19  -2  -0  -2  -2  -0   1 -13
       5|  -10   2   2  -2  -3   7   8  -5
       6|   -6  27  13   2   6  14  23   1
       7|   14  38  24  16  16  21  28   3
       8|   -3  34  23  15  12   8  19  -5

	
  .   .   .   .   .   .   .   .
-28  -4 -10 -32 -38 -42 -23 -27
-23  -5 -18 -29 -36 -39 -21 -30
-25  -8 -16 -17 -18 -30 -17 -20
-11   0 -13  -8 -17 -30  -6  -4
 16  33  23  22  29  33  38  32
 35  56  47  59  65  84  92  76
  .   .   .   .   .   .   .   .
                            
-74 -16 -40 -36 -40 -52 -31 -79
-31 -31 -15 -15 -15 -23 -34 -60
-25  -4  -2  11   7  -6 -18 -31
 -3  23  21  19   9  15  5  -18
 29  26  48  29  43  30  13   6
 32  39  58  50  48  32  26   2
 15  13  40  49  33  31  3   -7
-83  13  13  27  12  2   0 -105
                            
-33 -21 -16 -26 -22 -19 -14 -22
-16   0  -4  -7 -15   0 -10  -7
 -5  -2  -1   6   2   4   7  -5
 -5   5   0  16  20  10   8   3
  9  -6  23  23  27  18   0  -2
 23  27  29  27  28  18  20   6
  4   4  18  12  11  14  13   2
-11   2  -5   5   3   1   0  -5
                            
-43 -22 -32 -25 -21 -24 -30 -42
-37 -26 -30 -30 -29 -28 -33 -41
-21  -8 -20 -23 -24 -21 -17 -26
 -8   3   0  -4  -2  -2  -1  -8
 13  18  21  16  17  16  15  14
 25  32  34  31  30  30  28  23
 28  33  35  34  36  35  29  27
 29  23  24  26  28  25  24  21
                            
-55 -83 -80 -51 -41 -62 -65 -44
-52 -60 -51 -38 -38 -46 -45 -45
-16 -14 -26 -30 -38 -32 -45 -38
  1   3  -5 -10 -21 -22 -24 -41
 30  42  29  22  15   1 -17 -29
 58  96  76  50  28  12   6 -19
 86  60  61  43  32  24  -1 -13
 73  55  52  46  33  22  14   3









            if( LANES == 1 )
            {
                f->childSpec[0] = this->ChooseNextMove( f );
                f->childPos[0] = f->pos;
                f->childPos[0].Step( f->childSpec[0], whiteMat, blackMat );
                f->pos.CalcMoveMap( &f->childMoveMap[0] );
                f->childScore[0] = mEvaluator->Evaluate< POPCNT, SIMD >( f->pos, *f->childMoveMap[0], mWeights );

                f->simdIdx = 0;
            }
            else
            {


go depth 5
info depth 1 seldepth 1 score cp 74 hashfull 0 nodes 21 time 7 nps 21000 pv b1c3

info string DEBUG: simdnodes 20  >>>> 1: 74
info depth 2 seldepth 2 score cp 0 hashfull 0 nodes 100 time 24 nps 50000 pv g1f
3 b8c6
info string DEBUG: simdnodes 98  >>>> 2: 0
info depth 3 seldepth 3 score cp 74 hashfull 0 nodes 732 time 57 nps 43058 pv g1
f3 b8c6 b1c3
info string DEBUG: simdnodes 729  >>>> 3: 74
info depth 4 seldepth 8 score cp 0 hashfull 0 nodes 2363 time 129 nps 42963 pv g
1f3 b8c6 b1c3 g8f6
info string DEBUG: simdnodes 2359  >>>> 4: 0
info depth 5 seldepth 13 score cp 57 hashfull 0 nodes 17333 time 388 nps 70746 p
v g1f3 b8c6 b1c3 g8f6 e2e3
info string DEBUG: simdnodes 17328  >>>> 5: 57





    template< int POPCNT, typename SIMD >
    EvalTerm NegaMax( const Position& pos, const MoveMap& moveMap, EvalTerm score, int ply, int depth, EvalTerm alpha, EvalTerm beta, MoveList* pv_new, bool onPvPrev )
    {
        const int LANES = SimdWidth< SIMD >::LANES;

        mMetrics.mNodesTotal++;
        mMetrics.mNodesAtPly[ply]++;

        if( depth < 1 )
        {
            alpha = Max( alpha, score );
            
            if( alpha >= beta )
                return( beta );
        }

        if( mExitSearch )
            return( EVAL_SEARCH_ABORTED );

        if( POPCNT )
            mHashTable.Prefetch( pos.mHash );

        bool inCheck = (moveMap.IsInCheck() != 0);

        MoveList moves;
        moves.UnpackMoveMap( pos, moveMap );

        if( moves.mCount == 0 )
            return( inCheck? EVAL_CHECKMATE : EVAL_STALEMATE );

        if( depth < 1 )
        {
            if( !inCheck )
                moves.DiscardMovesBelow( CAPTURE_LOSING );

            if( moves.mCount == 0 )
                return( score );
        }

        if( depth > 0 )
        {
            TableEntry tt;

            mHashTable.Load( pos.mHash, tt );
            mMetrics.mHashLookupsAtPly[ply]++;

            u32 verify = (u32) (pos.mHash >> 40);
            if( tt.mHashVerify == verify )
            {
                mMetrics.mHashHitsAtPly[ply]++;

                bool        samePlayer          = (pos.mWhiteToMove != 0) == tt.mWhiteMove;
                bool        failedHighBefore    = samePlayer? tt.mFailHigh : tt.mFailLow;
                EvalTerm    lowerBoundBefore    = samePlayer? tt.mScore    : -tt.mScore;
                int         depthBefore         = tt.mDepth;

                if( failedHighBefore && (lowerBoundBefore >= beta) && (depthBefore >= depth) )
                    return( beta );

                moves.MarkSpecialMoves( tt.mBestSrc, tt.mBestDest, FLAG_TT_BEST_MOVE );
            }
        }

        if( onPvPrev && (mStorePv->mCount > ply) )
        {
            MoveSpec& pvMove = mStorePv->mMove[ply];
            moves.MarkSpecialMoves( pvMove.mSrc, pvMove.mDest, FLAG_PRINCIPAL_VARIATION );
        }

        int         movesTried  = 0;
        int         simdIdx     = LANES - 1;
        bool        nullSearch  = false;
        EvalTerm    bestScore   = alpha;
        MoveSpec    bestMove;

        MoveSpec PIGEON_ALIGN_SIMD childSpec[LANES];
        Position PIGEON_ALIGN_SIMD childPos[LANES];
        MoveMap  PIGEON_ALIGN_SIMD childMoveMap[LANES];
        EvalTerm PIGEON_ALIGN_SIMD childScore[LANES];

        while( (movesTried < moves.mCount) && (bestScore < beta) )
        {
            simdIdx++;
            if( simdIdx >= LANES )
            {
                MoveSpecT< SIMD >   simdSpec;
                PositionT< SIMD >   simdPos;
                MoveMapT< SIMD >    simdMoveMap;
                SIMD                simdScore;

                simdSpec.mSrc  = 0;
                simdSpec.mDest = 0;
                simdSpec.mType = 0;

                for( int idxLane = 0; idxLane < LANES; idxLane++ )
                {
                    if( moves.mTried >= moves.mCount )
                        break;

                    int idxMove = this->ChooseNextMove( moves, (int) pos.mWhiteToMove );
                    childSpec[idxLane] = moves.mMove[idxMove];

                    SimdInsert( simdSpec.mSrc,  childSpec[idxLane].mSrc,  idxLane );
                    SimdInsert( simdSpec.mDest, childSpec[idxLane].mDest, idxLane );
                    SimdInsert( simdSpec.mType, childSpec[idxLane].mType, idxLane );

                    mMetrics.mNodesTotalSimd++;
                }

                const MaterialTable* whiteMat = NULL;
                const MaterialTable* blackMat = NULL;

                if( 0 ) // FIXME
                {
                    whiteMat = &mMaterialTable[pos.mWhiteToMove];
                    blackMat = &mMaterialTable[pos.mWhiteToMove ^ 1];
                }

                simdPos.Broadcast( pos );
                simdPos.Step( simdSpec, whiteMat, blackMat );
                simdPos.CalcMoveMap( &simdMoveMap );
                simdScore = mEvaluator.Evaluate< POPCNT, SIMD >( simdPos, simdMoveMap, mRootWeights );

                Unswizzle< SIMD >( &simdPos,     childPos );
                Unswizzle< SIMD >( &simdMoveMap, childMoveMap );

				u64 PIGEON_ALIGN_SIMD unpackScore[LANES];
				*((SIMD*) unpackScore) = simdScore;

				for( int idxLane = 0; idxLane < LANES; idxLane++ )
					childScore[idxLane] = (EvalTerm) unpackScore[idxLane];

				simdIdx = 0;
            }

            bool allowMove = true;

            if( ply == 0 )
            {
                // TODO: make sure that this does not eliminate all valid moves! 

                bool repeatedPosition = (mPositionReps[childPos[simdIdx].mHash] > 1);
                bool notReadyToDraw   = (score < ALLOW_REP_SCORE);

                if( repeatedPosition && notReadyToDraw && !inCheck )
                {
                    allowMove = false;

                    if( mDebugMode )
                    {
                        printf( "info string preventing " );
                        FEN::PrintMoveSpec( childSpec[simdIdx] );
                        printf( " to avoid draw by repetition\n" );
                    }
                }
            }

            if( 1 )//allowMove )
            {
                MoveList pv_child;
                EvalTerm subScore;
            
                bool fullSearch = true;

                if( 0 )//nullSearch )
                {
                    subScore = -this->NegaMax< POPCNT, SIMD >( 
                        childPos[simdIdx], childMoveMap[simdIdx], childScore[simdIdx], ply + 1, depth - 1, -(bestScore + 1), -bestScore, 
                        &pv_child, (childSpec[simdIdx].mFlags & FLAG_PRINCIPAL_VARIATION)? true : false );
                
                    fullSearch = (subScore > bestScore) && (subScore < beta);
                }

                if( fullSearch )
                {
                    subScore = -this->NegaMax< POPCNT, SIMD >( 
                        childPos[simdIdx], childMoveMap[simdIdx], childScore[simdIdx], ply + 1, depth - 1, -beta, -bestScore, 
                        &pv_child, (childSpec[simdIdx].mFlags & FLAG_PRINCIPAL_VARIATION)? true : false );
                }

        //FEN::PrintMoveSpec( childSpec[simdIdx] );
        //printf( " %d\n", subScore );

                if( subScore > bestScore )
                {
                    bestScore   = subScore;
                    bestMove    = childSpec[simdIdx];
                    nullSearch  = true;

                    if( subScore < beta )
                    {
                        pv_new->mCount = 1;
                        pv_new->mMove[0] = bestMove;
                        pv_new->Append( pv_child );
                    }

                    if( depth > 1 )
                    {
                        int sidePlies       = ply >> 1;
                        int maxHistoryPlies = sizeof( mHistoryTable[0][0][0] ) * 8 - 1;
                        int historyBit      = maxHistoryPlies - sidePlies;

                        if( historyBit >= 0 )
                            mHistoryTable[pos.mWhiteToMove][bestMove.mDest][bestMove.mSrc] |= (1 << historyBit);
                    }
                }
            }

            if( (ply < METRICS_DEPTH) && (movesTried < METRICS_MOVES) )
                mMetrics.mMovesTriedByPly[ply][movesTried]++;

            movesTried++;

            //if( depth < -1 )
            //    break;
        }

        if( mExitSearch )
            return( EVAL_SEARCH_ABORTED );

        bool        failedHigh  = (bestScore >= beta);
        bool        failedLow   = (bestScore == alpha);
        EvalTerm    result      = failedHigh? beta : (failedLow? alpha : bestScore);

        if( depth > 0 )
        {
            TableEntry tt;

            tt.mHashVerify  = pos.mHash >> 40;
            tt.mDepth       = depth;
            tt.mScore       = result;
            tt.mBestSrc     = bestMove.mSrc;
            tt.mBestDest    = bestMove.mDest;
            tt.mFailLow     = failedLow;
            tt.mFailHigh    = failedHigh;
            tt.mWhiteMove   = pos.mWhiteToMove? true : false;

            mHashTable.Store( pos.mHash, tt );
        }

        return( result );
    }










